# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jDZBnikqgs0LIumeQeCAk9D2p_yVlC3j
"""

import scipy.io as io
import numpy as np
import matplotlib.pyplot as plt
import keras
from keras.models import Sequential
from keras.layers import Dense, Flatten
from keras.layers import Conv2D, MaxPooling2D
from keras import backend as k
from keras.utils import to_categorical
from keras.optimizers import SGD

# importing dataset and taking training and testing data
trX = io.loadmat('/content/drive/MyDrive/train_32x32.mat')['X']
trY = io.loadmat('/content/drive/MyDrive/train_32x32.mat')['y']
tsX = io.loadmat('/content/drive/MyDrive/test_32x32.mat')['X']
tsY = io.loadmat('/content/drive/MyDrive/test_32x32.mat')['y']

# normalizing the data
trX_norm = (trX - np.min(trX))/(np.max(trX)-np.min(trX))
tsX_norm = (tsX - np.min(tsX))/(np.max(tsX)-np.min(tsX))
# one hot vector encoding of labels
trY_vec = to_categorical(trY)
tsY_vec = to_categorical(tsY)

# initializing few parameters
batch_size = 32
num_classes = 10
epochs = 20
input_shape = (32,32,3)

# cnn architecture model with all the layers as mentioned 
model = Sequential()
model.add(Conv2D(64, kernel_size=(5,5), activation= 'relu', input_shape = input_shape, strides = 1, padding='same'))
model.add(MaxPooling2D(pool_size=(2,2), strides= 2))
model.add(Conv2D(64, kernel_size=(5,5), activation= 'relu', strides = 1, padding='same'))
model.add(MaxPooling2D(pool_size=(2,2), strides= 2))
model.add(Conv2D(128, kernel_size=(5,5), activation= 'relu', strides = 1, padding='same'))
model.add(Flatten())
model.add(Dense(3072, activation='relu'))
model.add(Dense(2048, activation='relu'))
model.add(Dense(num_classes, activation='softmax'))
# training the data using stochastic gradient descent optimizer
model.compile(SGD(learning_rate=0.05, decay = 1e-5), metrics=['accuracy'], loss = keras.losses.categorical_crossentropy)
# finding accuracy for the model
accuracy = model.fit(x= trX_norm, y= trY_vec, batch_size = batch_size, epochs=epochs, validation_data=(tsX_norm,tsY_vec))
# considering all different metrics from the above 
train_acc = accuracy.history['accuracy']
test_acc = accuracy.history['val_accuracy']
train_loss = accuracy.history['loss']
test_loss = accuracy.history['val_loss']
epoch_count = range(1,21)
# plotting loss with respect to number of epochs
plt.plot(epoch_count, train_loss, 'r--')
plt.plot(epoch_count, test_loss, 'b-')
plt.legend(['train_loss','test_loss'])
plt.xlabel('epochs')
plt.ylabel('loss')
plt.show()
# plotting accuracy with respect to number of epochs
plt.plot(epoch_count, train_acc)
plt.plot(epoch_count, test_acc)
plt.legend(['train_acc','test_acc'])
plt.xlabel('epochs')
plt.ylabel('acc')
plt.show()